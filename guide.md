# Simplified gRPC Guide

We want to construct a scenario with two entities:
* A server
* A client

and with the functionality that:
* The client can ask the server for the current time.
* The server will respond with its server name and the current time.

## How To

### Setting Up Files
1. Open an empty folder in your editor.
2. Run `go mod init someName` where 'someName' can be anything relevant. This will create a `go.mod` file with your chosen name at the top.
3. Create a folder named grpc (or something else) with a file proto file inside (for example `proto.proto`).
4. Create a client folder with a `client.go` file.
5. Create a server folder with a `server.go` file.
6. Put both the client and server into the same package by stating the package at the top of the files (for example ``package main``).

### Populating Proto File
Inside the `proto.proto` file we need to set up the service, service methods, and message type(s) we need. The methods are used for communicating between the entities, while the message types are used for input/output in the methods. The service contains the methods.

In our case, in the proto file, we want to have a:
* TimeAsk service
* Method for the client to ask the server for the time. 
* Type for the message the client will send to ask for the time.
* Type for the message the server will send back to the client with the time. 

Therefore, we add (where line 2-3 depends on the values above)
```
syntax = "proto3";

package simpleGuide;

option go_package = "grpc/proto";

message AskForTimeMessage {
    int64 clientId = 1;
}

message TimeMessage {
    string name = 1;
    int64 time = 2;
}

service TimeAsk {
    rpc AskForTime(AskForTimeMessage) returns (TimeMessage);
}
```
Then we run the command:

`protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative grpc/proto.proto`

where the last part specifies the path to the proto file. This should create two files inside the grpc folder (proto.pb.go and proto_grpc.go).
These files contain autogenerated code based on the things we implemented in the proto file.

### Setting Up Server

#### Making the server run

Now we need to set up the server. We will let the user determine which port is should run on via the flag "-port". 

1. Create a server struct with the necessary fields. You can read more about why the unimplemented part is needed [here](https://stackoverflow.com/questions/69700899/grpc-error-about-missing-an-unimplemented-server-method).

```
type Server struct { 
    proto.UnimplementedTimeAskServer // Necessary
    name                             string
}
```

2. Add a port variable and create a main which parses the flag, sets up a server struct, starts the server, and ensures that main will keep running.

```
var port = flag.Int("port", 0, "server port number")

func main() {
	// Get the port from the command line when the server is run
	flag.Parse()

	// Create a server struct
	server := &Server{
		name: "serverName",
	}

	// Start the server
	go startServer(server)

	// Keep the server running until it is manually quit
	for {

	}
}
```

You will need to add `"google.golang.org/grpc"`to the imports section and then run `go mod tidy` for the above code to work (specifically to be able to use the NewServer method).

Now you should be able to run, for example, ``go run server/server.go -port 5454`` and get the output `some_time_stamp Started server at port: 5454` (while the server keeps running).

#### Implementing Server Method

We now need to implement the `AskForTime` method we defined in the proto file, so that the client can call it.

To do so, we have to find the corresponding function inside the `proto_grpc.pb.go` file and copy its signature (in my case on line 32):

```
func (c *timeAskClient) AskForTime(ctx context.Context, in *AskForTimeMessage, opts ...grpc.CallOption) (*SendTime, error)
```

Copy this into the ``server.go`` file, turn it into a method (add {}) and do some changes:
* Import the context package. 
* Change timeAskClient to Server, so that it matches our server struct definition.
* Add *proto.AskForTimeMessage instead of just AskForTimeMessage as the in value (to point to the right type in the proto file).
* Add *proto.SendTime instead of just SendTime as the output.
* Remove the `opts ...grpc.CallOption` from the input.
* Temporarily make it return ``nil, nil``

We now have:
```
func (c *Server) AskForTime(ctx context.Context, in *proto.AskForTimeMessage) (*proto.TimeMessage, error) {
    return nil, nil
}
```
and there should not be any compile-errors. 

Now we will make the server actually return something and log which client is requesting the time. To do so, update the function to:
```
func (c *Server) AskForTime(ctx context.Context, in *proto.AskForTimeMessage) (*proto.TimeMessage, error) {
	log.Printf("Client with ID %d asked for the time\n", in.ClientId)
	return &proto.TimeMessage{Time: time.Now().String()}, nil
}
```

### Setting Up the Client

Similar to the server create a client struct, a port variable, set up the struct in main, and ensure that the client keeps running:
```
type Client struct {
	id int
}

var (
	port = flag.Int("port", 0, "client port number")
)

func main() {
	// Parse the flags to get the port for the client
	flag.Parse()

	// Create a client
	client := &Client{
		id: *port,
	}

	// Wait for the client (user) to ask for the time
	go waitForTimeRequest(client)

	for {
		
	}
}
```

Now we have to implement the `waitForTimeRequest` method.
